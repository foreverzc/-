# 作用域

## 一、局部作用域

> 局部作用域分为 函数作用域 和 块作用域

1. 函数作用域：

   在函数内部声明的变量只能在函数内部被访问，外部无法直接访问

   ``` js
       
   	<script>
           function getSum() {
               // 函数内部作用域 属于 局部变量
               const num = 10
           }
           console.log(num);//此处报错 函数外部 不能使用局部作用域变量
       </script>
   ```

   

总结

1. ==函数内部声明变量，在函数外部无法被访问==
2. 函数的参数也是函数内部的局部变量
3. 不同函数内部生命的变量无法互相访问
4. ==函数执行完毕后，函数内部的变量实际被清空了==



2. 块作用域

   在JavaScript中使用{}包裹的代码称为代码块，代码块内部声明的变量将  ==*有可能 *==无法被访问

   ``` JS
        for(let i = 0;i<3;i++){ //如果是var  声明的可以访问
           // 块作用域
           console.log(i);
        }
        console.log(i);//不能被访问  报错
   ```

   + let 声明的变量会产生块作用域，var不会产生 块级作用域
   + const  声明的常量 也会产生块级作用域
   + 不同代码块之间的变量无法互相访问
   + 推荐使用 let 或const

## 二、全局作用域

+ script 标签内部 和 .js文件 是全局作用域

+ 为window 对象动态添加的属性默认也是全局的，不推荐
+ 函数中未使用任何关键字生命的 变量也为全局变量 不推荐
+ 尽可能少的 声明全局变量 ，防止全局变量被污染





## 三、作用域链

==作用域链本质是底层的变量查找机制==

+ 函数被执行时，会==优先查找当前==函数作用域中查找变量
+ 如果当前作用域查不到则会依次==逐级查找父级作用域==直到全局作用域

总结

+ 1. 嵌套关系的作用域串联起来形成作用域链
+ 2. 相同作用域链中按着从小到大的规则查找变量
+ 3. ==子级作用域能够访问父级作用域，父级作用域无法访问子级作用域==



## 四、垃圾回收机制

==垃圾回收机制（Garbage Collection）称为  GC==

JS中==内存==的分配和回收都是==自动完成==的，内存在不使用的时候会被==垃圾回收器==自动回收



**内存的声名周期**

JS环境中分配的内存，一般有如下==生命周期==：

1. ==内存分配==：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2. ==内存使用==：即读写内存，也就是使用变量，函数等
3. ==内存回收==：使用完毕，由==垃圾回收器==自动回收不再使用的内存



说明：

+ 全局变量一般不会回收（关闭页面回收）
+ 一般请胯下局部变量的值，不用了 会被自动回收掉



**内存泄露**：程序分配的内存由于某种原因程序==未释放==或==无法释放==叫做内存泄露





## 五、垃圾回收机制——算法说明

### 引用计数

堆栈空间分配区别：

1. 栈（操作系统）：==由操作系统自动分配释放==的参数值、局部变量等，基本数据类型放到栈里面
2. 堆（操作系统）:   一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放到堆里面。

常见的浏览器垃圾回收算法：==引用计数法==和==标记清除法==

+ 引用计数法
  + IE采用的引用计数算法 定义‘==内存不再使用==’就是看一个 对象是否有指向它的引用，没有引用了 就回收对象
  + 算法
    + 1. 跟踪记录被引用的次数
    + 2. 如果被引用了一次，哪么就记录次数1，多次引用会累加++
    + 3. 如果减少一个引用就减1 --
    + 4. 如果引用次数是0，则释放内存
+ 缺点：嵌套引用(循环引用)
+ 如果==两个对象相互引用==，尽管他们不再使用辣鸡回收站不会进行回收，==导致内存泄露==

### 标记清除法

核心：从根部扫描对象，能查找到的就使用，查不到的就回收

+ 标记清除法将“不再使用的对象”定义为“==无法达到的对象==”
+ 就是从==根部（在JS中就是全局对象）==触发定时扫描内存中的对象。凡是能从==根部到达==的对象，都是还需要使用的
+ 哪些无法从根部触发触及到的对象被标记为不再使用，稍后进行回收



## 六 闭包

+ ==闭包的作用：封闭数据，实现数据私有，外部也可以访问函数内部 的变量==
+ ==闭包很有用，因为它允许将函数与其所操作的数据（环境）关联起来==
+ 引起的问题就是内存泄露

概念：一个函数对周围状态的引用捆绑在一起，内层函数中访问到其外层函数的作用域

简单理解：**闭包 = 内层函数+外层函数的变量**

==就是内层函数 引用了外层函数的变量==

例如

``` js
    function outer(){
      const a = 1
      function f(){
      	console.log(a)
      }
      f()
      }
    outer()
```



+ 闭包的作用：封闭数据，提供操作，==外部也可以访问函数内部的变量==

+ 闭包基本格式：

+ ``` js
          // 常见的闭包形式 ，外部可以访问使用  函数内部的变量
          function outer() {
              let i = 1
              function fn() {
                  console.log(i);
              }
              return fn
          }
          // outer() === fn === function fn(){}
          // fun = function fn(){}
          const fun = outer()
          fun()//调用这个函数
          // 外面要使用里面的函数
  ```



+ **闭包的应用**：==实现数据的私有==

+ ``` js
         // 闭包的应用  统计函数调用次数
          let i = 0
          function fn() {
              i++
              console.log(i);
          }
          // 因为i作为全局变量容易被修改
        
          // 改成闭包的形式
          function count(){
              let i = 0
              function fn(){
                  i++
                  console.log(i);
              }
              return fn
          }
          const fun = count()
          fun()
  ```

+ ==但是闭包可能会有内存泄漏的风险==





## 七 、变量提升

1. 变量在未声明即被访问时回报语法错误

2. 变量在var声明之前即被访问，变量的值为underfined

3. ==let/const 声明的变量不存在变量提升==

4. 变量提升出现在相同的作用域当中

5. ==实际开发中推荐先声明再访问变量==

   ``` js
           // 1.把所有var声明的变量 提升到 当前作用域 的最前面
           // 2.只提升声明 ，不提升赋值
           // 相当于吧 var num  提到了 前面 而值没提升
           console.log(num + '件');// underfined件
           var num = 10
   ```


